---
engine: knitr
---

# Clean and prepare {#sec-clean-and-prepare}

**Required material**

- Read *Data Feminism*, Chapter 5 'Unicorns, Janitors, Ninjas, Wizards, and Rock Stars', [@datafeminism2020]
- Read *R for Data Science*, Chapter 12 'Tidy data', [@r4ds]
- Read *What The Washington Post Elections Engineering team had to learn about election data* [@washingtonpostelections]
- Read *Column Names as Contracts*, [@columnnamesascontracts]

**Key concepts and skills**

- Cleaning and preparing a dataset is difficult work that involves a great deal of decision-making. Planning an endpoint and simulating the dataset that we would like to end up with are key elements of cleaning and preparing data.
- It can help to work in an iterative way, beginning with a small sample of the dataset. Write code to fix some aspect, and then iterate and generalize to additional tranches.
- During that process we should also develop a series of tests and checks that the dataset should pass. This should focus on key features that we would expect of the dataset.
- We should be especially concerned about the class of variables, having clear names, and that the values of each variable are as expected given all this.

**Key packages and functions**

- Core `tidyverse` [@tidyverse]
  - `dplyr` [@citedplyr]
    - `count()`
    - `mutate()`
    - `select()`
  - `stringr` [@citestringr]
    - `str_trim()`
    - `str_replace_all()`
  - `tidyr` [@citetidyr]
    - `pivot_longer()`
    - `separate()`
    - `separate_rows()`
- Outer `tidyverse` [@tidyverse]
  - `haven` [@citehaven]
    - `read_dta()`
  - `lubridate` [@GrolemundWickham2011]
    - `ymd()`
- `janitor` [@janitor]
  - `clean_names()`
- `pointblank` [@pointblank]
  - `create_agent()`
  - `col_is_character()`
  - `col_is_factor()`
  - `col_is_integer()`
  - `col_vals_in_set()`
  - `interrogate()`
- `purrr` [@citepurrr]
  - `map_dfr()`

## Introduction

> "Well, Lyndon, you may be right and they may be every bit as intelligent as you say," said Rayburn, "but I'd feel a whole lot better about them if just one of them had run for sheriff once."
> 
> Sam Rayburn's reaction to Lyndon Johnson's enthusiasm about Kennedy's incoming cabinet, as quoted in *The Best and the Brightest* [@halberstam, p. 41].

In this chapter we put in place more-formal approaches for data cleaning and preparation. These are centered around:

1. plausibility;
2. internal consistency; and
3. external consistency.

Plausibility means that the values in the dataset are not obviously wrong. For instance, with few exceptions, currencies should not have alphabetical values in them, names should not have numbers, and velocities should not be faster than the speed of light. Internal consistency means the dataset does not contradict itself. For instance, that might mean that constituent columns actually do add up to be the same as a total column. External consistency means that the dataset does not, in general, contradict outside sources, and is deliberate when it does. For instance, if our dataset purports to be about populations of cities in a country, then we would expect that they are the same as, to a rough approximation, say, those available from relevant censuses on Wikipedia.

SpaceX, the US rocket company, uses cycles of 10 or 50 Hertz (equivalent to 0.1 and 0.02 seconds, respectively) to control their rockets. Each cycle, the inputs from sensors, such as temperature and pressure, are read, processed, and used to make a decision, such as open a valve [@martinpopper]. We use a similar iterative approach of small adjustments for data cleaning and preparation. Rather than trying to make everything perfect from the start, we get started, and adjust on an iterative basis---a process of small, continuous, improvements.

To a large extent, the role of data cleaning and preparation is so great that the only people that we can trust understand their data, are those that who have cleaned it. And, the paradox of data cleaning is that often those that do the cleaning and preparation are those that have least trust in the resulting dataset. At some point in every data science workflow, those doing the modelling should get their hands dirty with data cleaning. To clean and prepare data is to make many decisions, some of which may have important effects on our results. For instance, @labelsiswrongs find the test sets of popular datasets in computer science contain, on average, around 3 per cent labeling errors. This has the potential to result in incorrect model selection.

For a long time, data cleaning and preparation was largely overlooked. We now realize that was a mistake. It has been difficult to trust results in disciplines that apply statistics for some time now. The reproducibility crisis, which started in psychology but has now extended to many other fields in the physical and social sciences, has brought to light issues such as p-value 'hacking', researcher degrees of freedom, file-drawer issues, and even data and results fabrication [@gelman2013garden]. Steps are now being put in place to address these. But there has been relatively little focus on the data gathering, cleaning, and preparation aspects of applied statistics, despite evidence that decisions made during these steps greatly affect statistical results [@huntington2021influence]. In this chapter we focus on these issues.

While the statistical practices that underpin data science are themselves correct and robust when applied to simulated datasets, data science is typically not conducted with these types of datasets. For instance, data scientists are interested in 'messy, unfiltered, and possibly unclean data---tainted by heteroskedasticity, complex dependence and missingness patterns---that until recently were avoided in polite conversations between more traditional statisticians' [@craiu2019hiring]. Big data does not resolve this issue, and may even exacerbate it, for instance population inference based on larger amounts of poor-quality data will just make us wrong more confidently [@meng2018statistical]. The issues that are found in much applied statistics research are not necessarily associated with researcher quality, or their biases [@silberzahn2018many]. Instead, they are a result of the environment within which data science is conducted. This chapter provides an approach and tools to explicitly think about this work.

@gelman2020most writing about the most important statistical ideas of the past 50 years say that each of them enabled new ways of thinking about data analysis and they brought into the tent of statistics, approaches that 'had been considered more a matter of taste or philosophy'. The focus on data cleaning and preparation in this chapter is analogous, insofar, as it represents a codification, or bringing inside the tent, of aspects that are typically, incorrectly, considered those of taste rather than statistics.

The workflow that we advocate is:

1. Save the raw data.
2. Begin with an end in mind.
3. Execute that plan on a small sample.
4. Write tests and documentation. 
5. Iterate the plan.
6. Generalize the execution.
7. Update tests and documentation.

We will need a variety of skills to be effective, but this is the very stuff of statistics. The approach needed is some combination of dogged and sensible. Perfect is very much the enemy of good enough when it comes to data cleaning. And to be specific, it is better to have 90 per cent of the data cleaned and prepared, and to start exploring that, before deciding whether it is worth the effort to clean and prepare the remaining 10 per cent. Because that remainder will likely take an awful lot of time and effort.

All data regardless of whether they were obtained from hunting, gathering, or farming, will have issues and it is critical that we have approaches that can deal with a variety of concerns, and more importantly, understand how it might affect our modelling [@van2005data]. To clean data is to analyze data. This is because the process forces us to make choices about what we value in our results [@thatrandyauperson].





## Workflow

### Save a copy of the raw data

The first step is to save the raw data into a separate, local, folder. It is important to save this raw data, to the extent that is possible, because it establishes the foundation for reproducibility [@wilsongoodenough]. If we are obtaining our data from a third-party, such as a government website, then we have no control over whether they will continue to host that data, whether they will update it, and the address at which it will be available. We also want to reduce the burden that we impose on their servers, by saving a local copy.

Having locally saved the raw data we must maintain it in that state, and not modify it. As we begin to clean and prepare it, we instead create another dataset. Maintaining the initial, raw, state of the dataset, and using scripts to create the dataset that we are interested in analyzing, ensures that our entire workflow is reproducible. 


### Begin with an end in mind

Planning the endpoint, or forcing yourself to begin with an end in mind, is important for a variety of reasons. As with scraping data, introduced in @sec-gather-data, it helps us to be proactive about scope-creep, but with data cleaning it additionally forces us to really think about what we want the final dataset to look like. 

The first step is to sketch the dataset that we are interested in. The key features of the sketch will be aspects such as the names of the columns, their class, and the possible range of values. For instance, we might be interested in the populations of US states. In which case our sketch might look like @fig-sketchdataplan.

![Planned dataset of US states and their populations](figures/state_population_sketch.png){#fig-sketchdataplan width=40% fig-align="center"}

In this case, the sketch forces us to decide that we want full names rather than abbreviations for the state names, and that the population has been measured in millions. The process of sketching this endpoint has forced us to make decisions early on, and be clear about our desired endpoint.

We then implement that using code to simulate data. Again, this process forces us to think about what reasonable values look like in our dataset because we are literally forced to decide which functions to use. We need to think carefully about the unique values of each variable. For instance, if the variable is meant to be 'gender' then values such as 'male', 'female', 'other', and 'unknown' may be expected, but a number such as '1,000' would likely be wrong. It also forces us to be explicit about names because we must assign the output of those functions to a variable. For instance, we could simulate some population data. 

```{r}
#| message: false
#| warning: false

library(tidyverse)

set.seed(853)

simulated_tfr <- 
  tibble(
    state = state.name,
    population = runif(n = 50, min = 0, max = 50) |> 
      round(digits = 2)
  )

simulated_tfr
```

Our purpose, during data cleaning and preparation, is to then bring our raw data close to that plan. Ideally, we would plan so that the desired endpoint of our dataset is 'tidy data', which was introduced in @sec-r-essentials. 

At this stage it is important to begin to think about plausibility and internal consistency. What are some of the features that we know these data should have?Note these down as you are simulating the dataset.



### Start small

Having thoroughly planned we can turn to the raw data that we are dealing with. Usually, regardless of what the raw data look like, we want to manipulate them into a rectangular dataset as quickly as possible. This allows us to use our familiar `tidyverse` approaches. For instance, let us assume that we are starting with a `.txt` file.

The first step is to look for regularities in the dataset. We want to end up with tabular data, which means that we need some type of delimiter to distinguish different columns. Ideally this might be features such as a comma, a semicolon, a tab, a double space, or a line break. For instance, here we would take advantage of the comma.

```
Alabama, 5
Alaska, 0.7
Arizona, 7
Arkansas, 3
California, 40
```

In more challenging cases there may be some regular feature of the dataset that we can take advantage of. For instance, sometimes various text is repeated, as here with 'State is' and 'and population is'.

```
State is Alabama and population is 5 million.
State is Alaska and population is 0.7 million.
State is Arizona and population is 7 million.
State is Arkansas and population is 3 million.
State is California and population is 40 million.
```

In this case, although we do not have a traditional delimiter, we can use the regularity of 'State is ' and ' and population is ' to get what we need. A more difficult case is when we do not have line breaks.

```
Alabama 5 Alaska 0.7 Arizona 7 Arkansas 3 California 40
```

One way to approach this is to take advantage of the different classes and values that we are looking for. For instance, in this case, we know that we are after US states, so there are only 50 possible options, and we could use the presence of these as a delimiter. We could also use the fact that population is a number here, and so split based on a space followed by a number.

We will now go through the process of converting this last example into tidy data using `tidyr` [@citetidyr].

```{r}
raw_data <-
  c('Alabama 5 Alaska 0.7 Arizona 7 Arkansas 3 California 40')

data_as_tibble <-
  tibble(raw = raw_data)

tidy_data <-
  data_as_tibble |>
  separate(col = raw,
           into = letters[1:5],
           sep = "(?<=[[:digit:]]) ") |>
  pivot_longer(cols = letters[1:5],
               names_to = "drop_me",
               values_to = "separate_me") |>
  separate(col = separate_me,
           into = c('state', 'population'),
           sep = " (?=[[:digit:]])") |>
  select(-drop_me)

tidy_data
```


### Write tests and documentation

Having established a rectangular dataset, albeit a messy one, we should begin to look at the classes that we have. We do not necessarily want to fix the classes at this point, because that can result in lost data. But we look at the class to see what it is, and then compare it to our simulated dataset to see where it needs to get to. We note the columns where it is different.

Before changing the class and before going onto more bespoke issues, we should deal with some of the common issues in each class. Some common issues are:

- Commas and other punctuation, such as denomination signs in columns that should be numeric.
- Inconsistent formatting of dates, such as 'December' and 'Dec' and '12'.
- Unexpected characters, especially in Unicode, which may not display consistently. By way of background, character encoding is needed for computers, which are based on strings of 0s and 1s, to be able to consider symbols such as alphabets. One source of particularly annoying data cleaning issues is different character encoding, particularly when dealing with foreign languages or odd characters. In general, we use UTF-8. The encoding of a character vector can be found using `Encoding()`.


Typically, we want to fix anything immediately obvious. For instance, remove commas that have been used to group digits in currencies. However, the situation will typically quickly become dire. What we need to do is to look at the unique values in each variable, and then triage what we will fix. We make the decision of how to triage based on what is likely to have the largest impact. That usually means starting with the counts, sorting in descending order, and then dealing with each as they come.

When the tests of membership are passed, then finally we can change the class, and run all the tests again. We are adapting this idea from the software development approach of unit testing. Tests are crucial because they enable us to understand whether software (or in this case data) is fit for purpose [@buildingsoftwaretogether].

Let us run through an example with a collection of strings, some of which are slightly wrong. This type of output is typical of OCR, which often gets most of the way there, but not quite.

```{r}
messy_string_1 <-
  c('Patricia, Ptricia, PatricIa, Patncia, PatricIa')
messy_string_2 <-
  c('Patricia, Patricia, Patric1a, Patricia , 8atricia')
messy_string <- paste(messy_string_1, messy_string_2, sep = ", ")
```

As before, we first want to get this into a rectangular dataset.

```{r}
messy_dataset <- 
  tibble(names = messy_string) |> 
  separate_rows(names, sep = ", ") 

messy_dataset
```

We now need decide which of these errors we are going to fix. To help us decide which are most important, we will create a count.

```{r}
messy_dataset |> 
  count(names, sort = TRUE)
```

The most common element is the correct one, which is great. The next one---'PatricIa'---looks like the 'i' has been incorrectly capitalized, and the one after that---'8atricia'---is distinguished by an '8' instead of a 'P'. Let us quickly fix these issues and then redo the count.

```{r}
messy_dataset_fix_I_8 <- 
  messy_dataset |> 
  mutate(names = str_replace_all(names, 'PatricIa', 'Patricia'),
         names = str_replace_all(names, '8atricia', 'Patricia')
         )

messy_dataset_fix_I_8 |> 
  count(names, sort = TRUE)
```

Already this is much better and 60 per cent of the values are correct, compared with earlier where it was 30 per cent. There are two more obvious errors---'Ptricia' and 'Patncia'---with the first missing an 'a' and the second having an 'n' where the 'ri' should be. Again, we can quickly update and fix those.

```{r}
messy_dataset_fix_a_n <- 
  messy_dataset_fix_I_8 |> 
  mutate(names = str_replace_all(names, 'Ptricia', 'Patricia'),
         names = str_replace_all(names, 'Patncia', 'Patricia')
         )

messy_dataset_fix_a_n |> 
  count(names, sort = TRUE)
```

We have achieved an 80 per cent fix with not too much effort. The two remaining issues are more subtle. The first has occurred because the 'i' has been incorrectly coded as an '1'. In some fonts this will show up, but in others it will be more difficult to see. This is a common issue, especially with OCR, and something to be aware of. The second is similarly subtle and is occurring because there is a trailing space. Again, trailing and leading spaces are a common issue and we can address them with `str_trim()`. After we fix these two remaining issues then we will have all entries corrected.

```{r}
cleaned_data <- 
  messy_dataset_fix_a_n |> 
  mutate(names = str_replace_all(names, 'Patric1a', 'Patricia'),
         names = str_trim(names, side = c("right"))
         )

rm(messy_dataset, messy_dataset_fix_I_8, messy_dataset_fix_a_n)

cleaned_data |> 
  count(names, sort = TRUE)
```

We have been doing the tests in our head in this example. We know that we are hoping for 'Patricia'. But we can start to document this test as well. One way is to look to see if values other than 'Patricia' exist in the dataset.

```{r}
check_me <- 
  cleaned_data |> 
  filter(names != "Patricia")

if (nrow(check_me) > 0) {
  print("Still have values that are not Patricia!")
}
```

We can make things a little more imposing by stopping our code execution if the condition is not met with `stopifnot()`. To use that we define a condition that we would like met. We could implement this type of check throughout our code. For instance, if we expected there to be a certain number of rows in the dataset, or for a certain column to have various properties, such as being an integer, or a factor.

```{r}
stopifnot(nrow(check_me) == 0)
```

We can use `stopifnot()` to ensure that our script is working as expected as it goes through.

Another way to write tests for our dataset is to use `testthat` [@testthat]. Although developed for testing packages, we can use the same functionality to test our datasets. For instance, we can use `expect_length()` to check the length of a dataset and `expect_equal()` to check the content.

```{r}
#| message: false
#| warning: false

library(testthat)

expect_length(check_me, 1)
expect_equal(class(cleaned_data$names), "character")
expect_equal(unique(cleaned_data$names), "Patricia")
```

If the tests pass then nothing happens, and if the tests fail then the script will stop.

What do we test? It is a difficult problem. The engineers working on the software for the Apollo program initially considered writing tests to be 'busy work' [@digitalapollo, p. 170]. But they eventually came to realize that NASA would not have faith that software could be used to send men to the moon unless it was accompanied by a comprehensive suite of tests. And it is the same for data science. 

Start with tests for plausibility. These will typically be aspects such as the class of the variables, and then their unique values. For instance, if we were using a recent dataset then columns that are years could be tested to ensure that all elements have four digits and start with a '2'. @peterbaumgartnertesting describes this as tests on the schema. After that turn to checks of internal consistency. For instance, if you have a column for different responses, then check that the sum of those is equal to a total column. Finally, turn to tests for external consistency. Here we want to use external information to inform our tests. For instance, if we had a column of, say, NMR for Germany (this concept was introduced in @sec-fire-hose), then we could look at the estimates from, say, the WHO, and ensure our column is consist with that.

We write tests throughout our scripts, rather than only right at the end. In particular using `stopifnot()` statements on as many intermediate steps as possible ensure that the dataset is being cleaned in a way that you are expecting. For instance, when merging two datasets we could check that the column names in the datasets are unique, apart from the column/s to be used as the key. Or that the number of observations of each type is being carried through appropriately. And even that the dimensions of the dataset are not being unexpectedly changed.


### Iterate, generalize and update

We could now iterate the plan. In this most recent case, we started with 10 entries. There is no reason that we could not increase this to 100 or even 1,000. We may need to generalize the cleaning procedures and tests. But eventually we would start to being the dataset into some sort of order.




## Checks and tests

Robert Caro, the biographer of Lyndon Johnson, spent years tracking down everyone connected to the 36th President of the United States. Caro went to far as to live in Texas Hill Country for three years so that he could better understand where Johnson was from. When Caro heard that Johnson, as a senator, would run to the Senate, he ran that route multiple times himself to try to understand why Johnson was running. Caro eventually understood it only when he ran the route as the sun was rising, just as Johnson had done---the sun hits the Senate Rotunda in a particularly inspiring way [@caroonworking, p. 156]. This background work enabled him to uncover aspects that no one else knew. For instance, it turns out that Johnson almost surely stole his first election win as a Texas senator [@caroonworking, p. 116]. We need to understand our data to this same extent. We must turn every page and go to every extreme.


The idea of negative space is well established in design. It refers to that which surrounds the subject. Sometimes negative space is used as an effect, for instance the logo of FedEx, an American logistics company, has negative space between the E and x that creates an arrow. In a similar way, we want to be cognizant of the data that we have, and the data that we do not have. We are worried that the data that we do not have somehow has meaning, potentially even to the extent of changing our conclusions. When we are cleaning data, we are looking for anomalies. We are interested in values that are in there that should not be, but also the opposite situation---values that are missing that should not be. There are four tools that we use to identify these situations: graphs, counts, checks, targets.

### Graphs

Graphs are an invaluable tool when cleaning data, because they show each point in the dataset, in relation to the other points. They are especially useful for identifying when a value does not belong. For instance, if a value is expected to be numerical, but it is still a character then it will not plot and a warning will be displayed.

Graphs will be especially useful for numerical data, but are still useful for text and categorical data. Let us pretend that we have a situation where we are interested in a person's age, for some youth survey. We have the following data:

```{r}
raw_data <- 
  tibble(ages = c(15.9, 14.9, 16.6, 15.8, 
                  16.7, 17.9, 12.6, 11.5, 
                  16.2, 19.5, 150)
         )

raw_data |> 
  ggplot(aes(y = ages, x = 0)) +
  geom_point()
```

The graph clearly shows the unexpected value of 150. The most likely explanation is that the data were incorrectly entered with a trailing 0, and should be 15. We can fix that, document it, and then redo the graph, so as to see that everything seems more reasonable now.

### Counts

We want to focus on getting most of the data right. So we are interested in the counts of unique values. Hopefully a majority of the data are concentrated in the most common counts. But it can also be useful to invert it, and see what is especially uncommon. The extent to which we want to deal with these depends on what we need. Ultimately, each time we fix one we are getting very few additional observations, potentially even just one! Counts are especially useful with text or categorical data, but can be helpful with numerical as well.

Let us see an example.

```{r}
raw_data <-
  tibble(
    country = c(
      'Australie', 'Austrelia', 'Australie',
      'Australie', 'Aeustralia', 'Austraia',
      'Australia', 'Australia', 'Australia',
      'Australia'
    )
  )

raw_data |> 
  count(country, sort = TRUE)
```

The use of this count clearly identifies where we should spend our time: changing 'Australie' to 'Australia' would almost double our amount of usable data.


### Checks

Some things are so important that we require that your cleaned dataset have them. These are conditions that we should check. They would typically come out of experience, expert knowledge, or the planning and simulation exercises. An example may be that there are no negative numbers in an age column, and no ages above 140.

For these we could specifically require that the condition is met. Another example is when doing cross-country analysis, then a list of country names that we know should be in our dataset would be useful. Our check conditions would then be if there were: 1) values not in that list in our dataset, or, vice versa; 2) countries that we expected to be in there that were not.

To have a concrete example, let us consider if we were doing some analysis about the five largest counties in Kenya: 'Nairobi', 'Kiambu', 'Nakuru', 'Kakamega', 'Bungoma'. Let us create that array first.

```{r}
correct_counties <- c('Nairobi', 
                      'Kiambu', 
                      'Nakuru', 
                      'Kakamega', 
                      'Bungoma')
```


We begin with the following dataset.

```{r}
top_five_kenya <- 
  tibble(county = c('Nairobi', 'Nairob1', 'Nakuru', 'Kakamega', 
                    'Nakuru', 'Kiambu', 'Kiambru', 'Kabamega', 
                    'Bun8oma', 'Bungoma')
  )

top_five_kenya |> 
  count(county, sort = TRUE)
```

Based on the count we know that we have to fix some of them and there are two with numbers that are obvious fixes.

```{r}
top_five_kenya <- 
  top_five_kenya |> 
  mutate(county = str_replace_all(county, 'Nairob1', 'Nairobi'),
         county = str_replace_all(county, 'Bun8oma', 'Bungoma')
  )

top_five_kenya |> 
  count(county, sort = TRUE)
```

At this point we can use our check conditions to decide whether we are finished or not.

```{r}
top_five_kenya$county |> unique()

if(all(top_five_kenya$county |> unique() == top_five_kenya)) {
  "Oh no"
}
if(all(top_five_kenya==top_five_kenya$county |> unique()) ) {
  "Oh no"
}
```

And so it is clear that we still have cleaning to do!

We may also find similar conditions from experts and those with experience in the particular field.



<!-- ### Targets -->

<!-- We could clean data indefinitely, but we need an endpoint. Part of this is sketching an endpoint, and simulating. But sometimes it helps to have a metric. This may be especially the case when we have a large dataset, a deadline, and a team, because the data cleaning stage is just one part of what needs to happen. One helpful aspect is to set targets against which we can judge a dataset and then just achieve those. -->

<!-- Let us turn to a common use-case which is merging two datasets. Of particular interest is the unique key between the two, which is  -->


<!-- Add in the notion of precision and recall. Maybe have a look at: -->

<!-- https://arxiv.org/pdf/2101.05308.pdf -->



### Class

It is often said that American society is obsessed with money, while British society is obsessed with class. In the case of data cleaning and preparation we need to be British. Explicit checks of the class of variables are essential. Accidentally assigning the wrong class to a variable can have a large effect on subsequent analysis. In particular:

- check whether some value should be a number or a factor; and
- check that dates are correctly formatted.

To understand why it is important to be clear about whether a value is a number or a factor, consider the following situation:

```{r}
some_data <- 
  tibble(response = c(1, 1, 0, 1, 0, 1, 1, 0, 0),
         group = c(1, 2, 1, 1, 2, 3, 1, 2, 3)) |> 
  mutate(group_as_integer = as.integer(group),
         group_as_factor = as.factor(group),
         )
```

Let us start with 'group' as an integer and look at a logistic regression.

```{r}
lm(response~group_as_integer, data = some_data) |> 
  summary()
```

Now we can try it as a factor. The interpretation of the variable is completely different.

```{r}
lm(response~group_as_factor, data = some_data) |> 
  summary()
```


### Dates

A shibboleth for whether someone has worked with dates before is their reaction when you tell them you are going to be working with dates. If they immediately involuntarily shudder and then share a horror story, then they have worked with dates before, and any other reaction means they have not. 

Extensive checking of dates is critical. Ideally, we would like dates to be in the following format: YYYY-MM-DD. There are differences of opinion as to what is an appropriate date format in the broader world, and reasonable people can differ on whether 1 July 2010 or July 1, 2020, is better, but YYYY-MM-DD is the format that is generally most appropriate for data.

In @sec-fire-hose we introduced a dataset on homeless shelter usage in Toronto in 2021 using `opendatatoronto` [@citeSharla]. Here we use that same dataset from earlier years to illustrate one process for checking dates. We first need to download the data.^[If this does not work, then the City of Toronto government may have moved the datasets. Instead use: `earlier_toronto_shelters <- read_csv('https://www.tellingstorieswithdata.com/inputs/data/earlier_toronto_shelters.csv', show_col_types = FALSE)`.]

```{r}
#| eval: false
#| echo: true

library(opendatatoronto)
library(tidyverse)

# Get the data
earlier_toronto_shelters <-
  search_packages("Daily Shelter Occupancy") |>
  list_package_resources() |>
  filter(
    name %in% c(
      "Daily shelter occupancy 2017.csv",
      "Daily shelter occupancy 2018.csv",
      "Daily shelter occupancy 2019.csv",
      "Daily shelter occupancy 2020.csv"
    )
  ) |>
  group_split(name) |>
  map_dfr(get_resource, .id = "file")

write_csv(
  x = earlier_toronto_shelters, 
  file = "earlier_toronto_shelters.csv"
  )
```

```{r}
#| eval: false
#| echo: false
#| warning: false

write_csv(
  x = earlier_toronto_shelters, 
  file = here::here("inputs/data/earlier_toronto_shelters.csv")
  )
```

```{r}
#| eval: true
#| echo: false
#| warning: false

earlier_toronto_shelters <- 
  read_csv(
    here::here("inputs/data/earlier_toronto_shelters.csv"),
    show_col_types = FALSE
    ) 
    
head(earlier_toronto_shelters)
```

We need to make the names easier to type, specify the year based on the file, and only keep relevant columns.

```{r}
library(janitor)

earlier_toronto_shelters <-
  earlier_toronto_shelters |> 
  clean_names() |>
  mutate(file = 
           case_when(
             file == "1" ~ 2017,
             file == "2" ~ 2018,
             file == "3" ~ 2019,
             file == "4" ~ 2020,
             TRUE ~ -1)
  ) |>
  select(-x_id, -facility_name, -organization_name, 
         -program_name, -shelter_address, -shelter_city)
```

The main issue with the dataset will be the dates. For 2017-2019 (inclusive) they appear to be year-month-day, but for 2020 they seem to be month-day-year. The separator is also inconsistent, changing from '-' to '/'. We first fix that, check our guesses, and then get to the main issue. When working with dates, we draw heavily on `lubridate` [@GrolemundWickham2011].

```{r}
#| warning: false
#| message: false

library(lubridate)

earlier_toronto_shelters <-
  earlier_toronto_shelters |>
  mutate(
    occupancy_date =
      str_remove(# remove times
        occupancy_date, "T[:digit:]{2}:[:digit:]{2}:[:digit:]{2}"),
    occupancy_date =
      str_replace_all(# make separation consistent
        occupancy_date, "/", "-")
  ) |>
  # Parsing differs between 2017-2019 and 2020.
  mutate(date = case_when(
    file == "2020" ~ mdy(occupancy_date, quiet = TRUE),
    file %in% c("2017", "2018", "2019") ~ ymd(occupancy_date, quiet = TRUE),
    TRUE ~ NA_Date_
  )) |>
  rename(year_from_file = file) |>
  select(year_from_file,
         date,
         occupancy_date,
         sector,
         occupancy,
         capacity)

earlier_toronto_shelters
```

We can check whether the guess of the date orderings was at least plausible by looking at the distribution of year (@tbl-homeless-yearcount-works), month (@fig-homeless-monthcount), and day components (@fig-homeless-daycount). We are interested in differences between the three years 2017-2019 and 2020.

```{r}
earlier_toronto_shelters <- 
  earlier_toronto_shelters |> 
  separate(occupancy_date, 
           into = c('one', 'two', 'three'), 
           sep = "-", 
           remove = FALSE)
```

```{r}
#| label: tbl-homeless-yearcount-works
#| tbl-cap: "Counts, by the first bit of occupancy date, for 2017-2020"

earlier_toronto_shelters |>
  count(one) |>
  rename(`First bit` = one, Number = n) |>
  knitr::kable(
    digits = 1,
    booktabs = TRUE,
    linesep = "",
    format.args = list(big.mark = ",")
  )
```


```{r}
#| label: fig-homeless-monthcount
#| fig-cap: "Counts, by the second bit of occupancy date, for 2017-2020"

earlier_toronto_shelters |> 
  count(year_from_file, two) |> 
  ggplot(aes(x = two, y = n)) +
  geom_point() +
  theme_minimal() +
  labs(x = "Second bit of occupancy date",
       y = "Number") +
  facet_wrap(vars(year_from_file),
             scales = "free", 
             nrow = 2,
             ncol = 2)
```


```{r}
#| label: fig-homeless-daycount
#| fig-cap: "Counts, by third bit of occupancy date, of entries for 2017-2020"

earlier_toronto_shelters |> 
  count(year_from_file, three) |> 
  ggplot(aes(x = three, y = n)) +
  geom_point() +
  theme_minimal() +
  labs(x = "Third bit of occupancy date",
       y = "Number") +
  facet_wrap(vars(year_from_file),
             scales = "free", 
             nrow = 2,
             ncol = 2)
```

It is increasingly clear that our guess that the order was swapped around for 2020 seems right. We would be especially concerned if the distribution of the days was not roughly uniform, or if we have values other than [1-12] in the month.

```{r}
#| eval: true
#| echo: false

earlier_toronto_shelters <- 
  earlier_toronto_shelters |> 
  select(-occupancy_date, -one, -two, -three, -year_from_file)
```

One graph that is especially useful when cleaning a dataset is the order the observations appear in the dataset. For instance, we would generally expect that there would be a rough ordering in terms of date. To examine whether this is the case, we can graph the date variable in the order it appears in the dataset (@fig-plotorder). 

```{r}
#| label: fig-plotorder
#| fig-cap: "Comparison of row number with date"

earlier_toronto_shelters |> 
  mutate(row_number = c(1:nrow(earlier_toronto_shelters))) |> 
  ggplot(aes(x = row_number, y = date), alpha = 0.1) +
  geom_point() +
  theme_minimal() +
  labs(x = "Row number",
       y = "Date")
```

While this is just a quick graph it illustrates the point which is that the data are not in order in the dataset. If they were in order, then we would expect them to be along the diagonal. It is odd that the data are not in order, especially as there appears to be something systematic initially. We can summarize the data to get a count of occupancy by day.

```{r}
library(tidyr)

# Based on code by Lisa Lendway
toronto_shelters_by_day <- 
  earlier_toronto_shelters |> 
  # We only want rows with both occupancy and capacity  
  drop_na(occupancy, capacity) |> 
  # We want to know the occupancy by date and sector
  group_by(date) |> 
  summarize(occupancy = sum(occupancy),
            capacity = sum(capacity),
            usage = occupancy / capacity, .groups = 'drop')
```

We are interested in availability of shelter spots in Toronto for each day (@fig-plotoccupancy-1). And we can focus on 2017, as that is where the biggest issue is and facet by month (@fig-plotoccupancy-2).

```{r}
#| label: fig-plotoccupancy
#| fig-cap: "Occupancy per day in Toronto shelters"
#| fig-subcap: ["In 2017-2020","Only in 2017"]
#| layout-ncol: 2

toronto_shelters_by_day |> 
  ggplot(aes(x = date, y = occupancy)) + 
  geom_point(alpha = 0.3) +
  scale_y_continuous(limits = c(0, NA)) +
  labs(color = "Type",
       x = "Date",
       y = "Occupancy (number)") +
  theme_minimal() +
  scale_color_brewer(palette = "Set1")

toronto_shelters_by_day |> 
  filter(year(date) == 2017) |> 
  ggplot(aes(x = day(date), y = occupancy)) + 
  geom_point(alpha = 0.3) +
  scale_y_continuous(limits = c(0, NA)) +
  labs(color = "Type",
       x = "Day",
       y = "Occupancy (number)") +
  facet_wrap(vars(month(date, label = TRUE)),
             scales = "free_x") +
  theme_minimal() +
  scale_color_brewer(palette = "Set1")
```
 
<!-- This gives us an idea of what we ought to expect in 2017---why should they be significantly different? To start, focus on January 2017 and see if that makes it clearer what is going on (@fig-sheltersinjan2017-1). This perhaps gives us some idea of what is going on. We can also just check February and see if it looks similar (@fig-sheltersinjan2017-2). -->

<!-- ```{r} -->
<!-- #| label: fig-sheltersinjan2017 -->
<!-- #| fig-cap: "Daily occupancy in Toronto shelters in January and February 2017" -->
<!-- #| fig-subcap: ["Occupancy in January 2017","Occupancy in February 2017"] -->
<!-- #| layout-ncol: 2 -->

<!-- toronto_shelters_by_day |>  -->
<!--   filter(year(date) == 2017) |> -->
<!--   filter(month(date) == 1) |>  -->
<!--   ggplot(aes(x = day(date), y = occupancy)) +  -->
<!--   geom_point() + -->
<!--   scale_y_continuous(limits = c(0, NA)) + -->
<!--   labs(color = "Type", -->
<!--        x = "Day", -->
<!--        y = "Occupancy (number)") + -->
<!--   theme_minimal() + -->
<!--   scale_color_brewer(palette = "Set1") -->

<!-- toronto_shelters_by_day |>  -->
<!--   filter(year(date) == 2017) |> -->
<!--   filter(month(date) == 2) |>  -->
<!--   ggplot(aes(x = day(date), y = occupancy)) +  -->
<!--   geom_point() + -->
<!--   scale_y_continuous(limits = c(0, NA)) + -->
<!--   labs(color = "Type", -->
<!--        x = "Day", -->
<!--        y = "Occupancy (number)") + -->
<!--   theme_minimal() + -->
<!--   scale_color_brewer(palette = "Set1") -->
<!-- ``` -->



<!-- (@fig-sheltersin2017byrow). -->

<!-- ```{r} -->
<!-- #| label: fig-sheltersin2017byrow -->
<!-- #| fig-cap: "Date of each row in order in 2017" -->

<!-- earlier_toronto_shelters |>  -->
<!--   mutate(counter = 1:nrow(earlier_toronto_shelters)) |>  -->
<!--   filter(year(date) == 2017) |>  -->
<!--   ggplot(aes(x = counter, y = date)) + -->
<!--   geom_point(alpha = 0.3) + -->
<!--   labs(x = "Row in the dataset", -->
<!--        y = "Date of that row") + -->
<!--   theme_minimal() -->
<!-- ``` -->

It is clear there is an issue with the first twelve days of the month. We noted at the start that when we look at the data it is a bit odd in that it is not in order. We can take another look at that by going back to the data as it was given to us (as opposed to the data by day that we have been using). Although there is no rule that says the dataset must be in order of the date, if it were, then all the points would lie on the diagonal line. We have a lot of deviation from that. To get a sense of what we are expecting let us look at all four years (@fig-sheltersdatebyrow).

```{r}
#| label: fig-sheltersdatebyrow
#| fig-cap: "Date of each row in order (2017-2020)"

earlier_toronto_shelters |> 
  mutate(counter = 1:nrow(earlier_toronto_shelters)) |> 
  ggplot(aes(x = counter, y = date)) +
  geom_point(alpha = 0.3) +
  facet_wrap(vars(year(date)),
             scales = "free") +
  labs(x = "Row in the dataset",
       y = "Date of that row") +
  theme_minimal()
```

It looks like 2020 is as we would expect. 2019 has a few odd situations, but not too many. 2018 has a small cluster early in the dataset and then possibly something systematic toward the middle. But it is clear that 2017 has a large number of systematic issues.

In general, it seems that it might be the case that in 2017 the first 12 days are the wrong way around, i.e. we think it is year-month-day, but it is actually year-day-month, but there are exceptions. As a first pass, we can flip those first 12 days of each month and see if that helps. It will be fairly blunt, but hopefully gets us somewhere.

```{r}
list_of_dates <- c(
  "2017-02-01", "2017-03-01", "2017-04-01", "2017-05-01", "2017-06-01", 
  "2017-07-01", "2017-08-01", "2017-09-01", "2017-10-01", "2017-11-01", 
  "2017-12-01", "2017-01-02", "2017-03-02", "2017-04-02", "2017-05-02", 
  "2017-06-02", "2017-07-02", "2017-08-02", "2017-09-02", "2017-10-02", 
  "2017-11-02", "2017-12-02", "2017-01-03", "2017-02-03", "2017-04-03", 
  "2017-05-03", "2017-06-03", "2017-07-03", "2017-08-03", "2017-09-03", 
  "2017-10-03", "2017-11-03", "2017-12-03", "2017-01-04", "2017-02-04", 
  "2017-03-04", "2017-05-04", "2017-06-04", "2017-07-04", "2017-08-04", 
  "2017-09-04", "2017-10-04", "2017-11-04", "2017-12-04", "2017-01-05", 
  "2017-02-05", "2017-03-05", "2017-04-05", "2017-06-05", "2017-07-05", 
  "2017-08-05", "2017-09-05", "2017-10-05", "2017-11-05", "2017-12-05", 
  "2017-01-06", "2017-02-06", "2017-03-06", "2017-04-06", "2017-05-06", 
  "2017-07-06", "2017-08-06", "2017-09-06", "2017-10-06", "2017-11-06", 
  "2017-12-06", "2017-01-07", "2017-02-07", "2017-03-07", "2017-04-07", 
  "2017-05-07", "2017-06-07", "2017-08-07", "2017-09-07", "2017-10-07", 
  "2017-11-07", "2017-12-07", "2017-01-08", "2017-02-08", "2017-03-08", 
  "2017-04-08", "2017-05-08", "2017-06-08", "2017-07-08", "2017-09-08", 
  "2017-10-08", "2017-11-08", "2017-12-08", "2017-01-09", "2017-02-09", 
  "2017-03-09", "2017-04-09", "2017-05-09", "2017-06-09", "2017-07-09", 
  "2017-08-09", "2017-10-09", "2017-11-09", "2017-12-09", "2017-01-10", 
  "2017-02-10", "2017-03-10", "2017-04-10", "2017-05-10", "2017-06-10", 
  "2017-07-10", "2017-08-10", "2017-09-10", "2017-11-10", "2017-12-10", 
  "2017-01-11", "2017-02-11", "2017-03-11", "2017-04-11", "2017-05-11", 
  "2017-06-11", "2017-07-11", "2017-08-11", "2017-09-11", "2017-10-11", 
  "2017-12-11", "2017-01-12", "2017-02-12", "2017-03-12", "2017-04-12", 
  "2017-05-12", "2017-06-12", "2017-07-12", "2017-08-12", "2017-09-12", 
  "2017-10-12", "2017-11-12")

earlier_toronto_shelters <- 
  earlier_toronto_shelters |> 
  mutate(
    year = year(date),
    month = month(date),
    day = day(date),
    date = as.character(date),
    changed_date = if_else(
      date %in% list_of_dates,
      paste(year, day, month, sep = "-"),
      paste(year, month, day, sep = "-"),
    ),
    changed_date = ymd(changed_date)
    ) |> 
  select(-year, -month, -day)
```

Now let us take a look (@fig-sheltersdatebyrowadj).

```{r}
#| label: fig-sheltersdatebyrowadj
#| fig-cap: "Date of each row in order in 2017 after adjustment"

earlier_toronto_shelters |> 
  mutate(counter = 1:nrow(earlier_toronto_shelters)) |> 
  filter(year(date) == 2017) |> 
  ggplot(aes(x = counter, y = changed_date)) +
  geom_point(alpha = 0.3) +
  labs(x = "Row in the dataset",
       y = "Date of that row") +
  theme_minimal()
```

We can see that has almost entirely taken care of the systematic differences. However, it is probably a little blunt. For instance, notice there are now no entries below the diagonal (@fig-sheltersdatebyrowadj2017).

```{r}
#| label: fig-sheltersdatebyrowadj2017
#| fig-cap: "Toronto shelters daily occupancy in 2017 after adjustment"

toronto_shelters_adjusted <- 
  earlier_toronto_shelters |> 
  # We only want rows with occupancy
  tidyr::drop_na(occupancy, capacity) |> 
  # We want to know the occupancy by date and sector
  group_by(changed_date) |> 
  summarise(occupancy = sum(occupancy), .groups = 'drop') 

toronto_shelters_adjusted |> 
  filter(year(changed_date) == 2017) |> 
  ggplot(aes(x = day(changed_date), y = occupancy)) + 
  geom_point(alpha = 0.3) +
  scale_y_continuous(limits = c(0, NA)) +
  labs(color = "Type",
       x = "Changed day",
       y = "Occupancy (number)") +
  facet_wrap(vars(month(changed_date, label = TRUE)),
             scales = "free_x") +
  theme_minimal() +
  scale_color_brewer(palette = "Set1")
```


## Cleaning the 2019 Kenyan census

### Gather and clean data

To make this all clearer, let us gather, clean, and prepare some data from the 2019 Kenyan census. The distribution of population by age, sex, and administrative unit from the 2019 Kenyan census can be downloaded [here](https://www.knbs.or.ke/?wpdmpro=2019-kenya-population-and-housing-census-volume-iii-distribution-of-population-by-age-sex-and-administrative-units). While this format as a PDF makes it easy to look up a particular result, it is not overly useful if we want to model the data. In order to be able to do that, we need to convert a PDF of Kenyan census results of counts, by age and sex, by county and sub-county, into a tidy dataset that can be analyzed. We use `janitor` [@janitor], `pdftools` [@pdftools], `tidyverse` [@tidyverse], and `stringi` [@stringi].

```{r}
#| message: false
#| warning: false

library(janitor)
library(pdftools)
library(purrr)
library(tidyverse)
library(stringi)
```

We first need to download and read in the PDF of the 2019 Kenyan census.^[If the Kenyan government link breaks then replace their URL with: https://www.tellingstorieswithdata.com/inputs/pdfs/2019_Kenya_census.pdf.] 

```{r}
#| eval: false
#| include: true

download.file(
  "https://www.knbs.or.ke/download/2019-kenya-population-and-housing-census-volume-iii-distribution-of-population-by-age-sex-and-administrative-units/?wpdmdl=5729&refresh=620561f1ce3ad1644519921", 
  "2019_Kenya_census.pdf",
  mode="wb")
```

When we have a PDF and want to read the content into R, then `pdf_text()` from `pdftools` [@pdftools] is useful. It works well for many recently produced PDFs because the content is text which it can extract. But if the PDF is an image, then `pdf_text()` will not work. Instead, the PDF will first need to go through OCR, which was introduced in @sec-gather-data.

```{r}
#| eval: false
#| include: true

all_content <- pdf_text("2019_Kenya_census.pdf")
```

```{r}
#| eval: true
#| include: false

# INTERNAL

all_content <- pdf_text("inputs/pdfs/2019_Kenya_census.pdf")
```

We can see an example page of the PDF of the 2019 Kenyan census (@fig-examplekenyancensuspage).

![Example page from the 2019 Kenyan census](figures/2020-04-10-screenshot-of-census.png){#fig-examplekenyancensuspage width=95% fig-align="center"}

#### Make rectangular

The first challenge is to get the dataset into a format that we can more easily manipulate. We will consider each page of the PDF and extract the relevant parts. To do this, we first write a function, and then apply it to each page. 

```{r}
# The function is going to take an input of a page
get_data <- function(i){
  # Just look at the page of interest
  # Based on Bob Rudis: https://stackoverflow.com/a/47793617
  just_page_i <- stri_split_lines(all_content[[i]])[[1]] 
  
  just_page_i <- just_page_i[just_page_i != ""]
  
  # Grab the name of the location
  area <- just_page_i[3] |> str_squish()
  area <- str_to_title(area)
  
  # Grab the type of table
  type_of_table <- just_page_i[2] |> str_squish()
  
  # Manually get rid of the top matter for now
  just_page_i_no_header <- just_page_i[5:length(just_page_i)] 
  
  # Manually get rid of the bottom matter for now
  just_page_i_no_header_no_footer <- just_page_i_no_header[1:62] 
  
  # Convert into a tibble
  demography_data <- tibble(all = just_page_i_no_header_no_footer)
  
  # Split columns
  demography_data <-
    demography_data |>
    mutate(all = str_squish(all)) |> # Any space more than two spaces is reduced
    mutate(all = str_replace(all, "10 -14", "10-14")) |> # One specific issue
    mutate(all = str_replace(all, "Not Stated", "NotStated")) |> # And another
    separate(col = all,
             into = c("age", "male", "female", "total", "age_2", 
                      "male_2", "female_2", "total_2"),
             sep = " ", # Works fine because the tables are nicely laid out
             remove = TRUE,
             fill = "right",
             extra = "drop"
    )
  
  # They are side by side at the moment, need to append to bottom
  demography_data_long <-
    rbind(demography_data |> select(age, male, female, total),
          demography_data |>
            select(age_2, male_2, female_2, total_2) |>
            rename(age = age_2, male = male_2, 
                   female = female_2, total = total_2)
    )
  
  # There is one row of NAs, so remove it
  demography_data_long <- 
    demography_data_long |> 
    remove_empty(which = c("rows"))
  
  # Add the area and the page
  demography_data_long$area <- area
  demography_data_long$table <- type_of_table
  demography_data_long$page <- i
  
  rm(just_page_i,
     i,
     area,
     type_of_table,
     just_page_i_no_header,
     just_page_i_no_header_no_footer,
     demography_data)
  
  return(demography_data_long)
}
```

We now have a function that does what we need to each page of the PDF. We will use `map_dfr()` from `purrr` [@citepurrr] to apply that function to each page, and then combine all the outputs into one tibble.

```{r}
# Run through each relevant page and get the data
pages <- c(30:513)
all_tables <- map_dfr(pages, get_data)
rm(pages, get_data)
```

```{r}
all_tables
```

Having got it into a rectangular format, we now need to clean the dataset to make it useful.

#### Plausibility

The first step is to make the numbers into actual numbers, rather than characters. Before we can convert the type, we need to remove anything that is not a number otherwise that cell will be converted into an NA. We first identify any values that are not numbers so that we can remove them, and `distinct()` is especially useful. 

```{r}
# Need to convert male, female, and total to integers
# First find the characters that should not be in there
all_tables |> 
  select(male, female, total) |>
  mutate_all(~str_remove_all(., "[:digit:]")) |> 
  distinct()
```

We clearly need to remove ',', '_', and '-'. While we could use `janitor` here, it is worthwhile at least first looking at what is going on because sometimes there is odd stuff that `janitor` (and other packages) will deal with, but not in a way that we want. We also have an odd situation with some months in what should be a numerical variable. In this case, the Kenyan government used Excel or similar, and this has converted two entries into dates. If we just took the numbers from the variable then we would have 23 and 15 here, but by inspecting the column we can use Excel to reverse the process and enter the correct values of 4,923 and 4,611, respectively.

```{r}
# This also highlights a few issues on p. 185 that need to be manually adjusted
all_tables$male[all_tables$male == "23-Jun"] <- 4923
all_tables$male[all_tables$male == "15-Aug"] <- 4611
```

Having identified everything that needs to be removed, we can do the actual removal and convert our character column of numbers to integers.

```{r}
#| echo: true

all_tables <-
  all_tables |>
  mutate_at(vars(male, female, total), ~str_remove_all(., ",")) |>
  mutate_at(vars(male, female, total), ~str_replace(., "_", "0")) |>
  mutate_at(vars(male, female, total), ~str_replace(., "-", "0")) |>
  mutate_at(vars(male, female, total), ~as.integer(.))

all_tables
```

#### Internal consistency

##### Areas

The next thing to clean is the areas. We know that there are 47 counties in Kenya, and a large number of sub-counties. The Kenyan government purports to provide a list on pages 19 to 22 of the PDF (document pages 7 to 10). But this list is not complete, and there are a few minor issues that we will deal with later. In any case, we first need to fix a few inconsistencies.

```{r}
# Fix some area names
all_tables$area[all_tables$area == "Taita/ Taveta"] <- "Taita/Taveta"
all_tables$area[all_tables$area == "Elgeyo/ Marakwet"] <- "Elgeyo/Marakwet"
all_tables$area[all_tables$area == "Nairobi City"] <- "Nairobi"
```

Kenya has 47 counties, each of which has sub-counties. The PDF has them arranged as the county data then the sub-counties, without designating which is which. We can use the names, to a certain extent, but in a handful of cases, there is a sub-county that has the same name as a county, so we need to first fix that.

The PDF is made-up of three tables. So we can first get the names of the counties based on those final two tables and then reconcile them to get a list of the counties.

```{r}
#| echo: true

all_tables$table |> 
  table()
```

```{r}
#| echo: true

list_counties <- 
  all_tables |> 
  filter(table %in% c("Table 2.4a: Distribution of Rural Population by Age, Sex* and County",
                      "Table 2.4b: Distribution of Urban Population by Age, Sex* and County")
         ) |> 
  select(area) |> 
  distinct()

list_counties
```

As we hoped, there are 47 of them. But before we can add a flag based on those names, we need to deal with the sub-counties that share their name. We will do this based on the page, then looking it up and deciding which is the county page and which is the sub-county page.

```{r}
#| echo: true

all_tables |> 
  filter(table == "Table 2.3: Distribution of Population by Age, Sex*, County and Sub- County") |> 
  filter(area %in% c("Busia",
                     "Garissa",
                     "Homa Bay",
                     "Isiolo",
                     "Kiambu",
                     "Machakos",
                     "Makueni",
                     "Samburu",
                     "Siaya",
                     "Tana River",
                     "Vihiga",
                     "West Pokot")
         ) |> 
  select(area, page) |> 
  distinct()
```

Now we can add the flag for whether the area is a county, and adjust for the ones that are troublesome.

```{r}
#| echo: true

all_tables <- 
  all_tables |> 
  mutate(area_type = if_else(area %in% list_counties$area, 
                             "county", 
                             "sub-county")
         )

all_tables <- 
  all_tables |> 
  mutate(area_type = case_when(
    area == "Samburu" & page == 42 ~ "sub-county",
    area == "Tana River" & page == 56 ~ "sub-county",
    area == "Garissa" & page == 69 ~ "sub-county",
    area == "Isiolo" & page == 100 ~ "sub-county",
    area == "Machakos" & page == 154 ~ "sub-county",
    area == "Makueni" & page == 164 ~ "sub-county",
    area == "Kiambu" & page == 213 ~ "sub-county",
    area == "West Pokot" & page == 233 ~ "sub-county",
    area == "Vihiga" & page == 333 ~ "sub-county",
    area == "Busia" & page == 353 ~ "sub-county",
    area == "Siaya" & page == 360 ~ "sub-county",
    area == "Homa Bay" & page == 375 ~ "sub-county",
    TRUE ~ area_type
    )
  )

rm(list_counties)

all_tables
```

##### Ages

Having dealt with the areas, we can deal with the ages. First, we need to fix some clear errors.

```{r}
table(all_tables$age) |> head()
unique(all_tables$age) |> head()

# Looks like there should be 484, so need to follow up on some:
all_tables$age[all_tables$age == "NotStated"] <- "Not Stated"
all_tables$age[all_tables$age == "43594"] <- "5-9"
all_tables$age[all_tables$age == "43752"] <- "10-14"
all_tables$age[all_tables$age == "9-14"] <- "5-9"
all_tables$age[all_tables$age == "10-19"] <- "10-14"
```

The census has done some of the work of putting together age-groups for us, but we want to make it easy to just focus on the counts by single-year-age. As such we will add a flag as to the type of age it is: an age group, such as "ages 0 to 5", or a single age, such as "1".

```{r}
all_tables$age_type <-
  if_else(str_detect(all_tables$age, c("-")), "age-group", "single-year")
all_tables$age_type <-
  if_else(str_detect(all_tables$age, c("Total")),
          "age-group",
          all_tables$age_type)
```

At the moment, age is a character variable. We have a decision to make here. We do not want it to be a character variable (because it will not graph properly), but we do not want it to be numeric, because there is `total` and `100+` in there. For now, we will just make it into a factor, and at least that will be able to be nicely graphed.

```{r}
all_tables$age <- as_factor(all_tables$age)
```



### Check data

Having gathered and cleaned the data, we would like to run a few checks. Given the format of the data, we can check that 'total' is the sum of 'male' and 'female'. (While we would prefer to use different groupings, this is what the Kenyan government collected and makes available.)

```{r}
#| echo: true

follow_up <- 
  all_tables |> 
  mutate(check_sum = male + female,
         totals_match = if_else(total == check_sum, 1, 0)
         ) |> 
  filter(totals_match == 0)
```

And we can adjust the one that looks to be wrong.

```{r}
#| echo: true

# There is just one that looks wrong
all_tables$male[all_tables$age == "10" & all_tables$page == 187] <- as.integer(1)

rm(follow_up)
```

The Kenyan census provides different tables for the total of each county and sub-county; and then within each county, for the number in an urban area in that county, and the number in a urban area in that county. Some counties only have an urban count, but we would like to make sure that the sum of rural and urban counts equals the total count. This requires pivoting the data from long to wide.

First, we construct different tables for each of the three. 

```{r}
#| echo: true

# Table 2.3
table_2_3 <- all_tables |> 
  filter(table == "Table 2.3: Distribution of Population by Age, Sex*, County and Sub- County")
table_2_4a <- all_tables |> 
  filter(table == "Table 2.4a: Distribution of Rural Population by Age, Sex* and County")
table_2_4b <- all_tables |> 
  filter(table == "Table 2.4b: Distribution of Urban Population by Age, Sex* and County")
```

Then having constructed the constituent parts, we can join them based on age, area, and whether it is a county.

```{r}
#| echo: true
#| 
both_2_4s <-
  full_join(
    table_2_4a,
    table_2_4b,
    by = c("age", "area", "area_type"),
    suffix = c("_rural", "_urban")
  )

all <-
  full_join(
    table_2_3,
    both_2_4s,
    by = c("age", "area", "area_type"),
    suffix = c("_all", "_")
  )

all <-
  all |>
  mutate(
    page = glue::glue(
      'Total from p. {page}, rural from p. {page_rural}, urban from p. {page_urban}'
    )
  ) |>
  select(
    -page,
    -page_rural,
    -page_urban,-table,
    -table_rural,
    -table_urban,-age_type_rural,
    -age_type_urban
  )

rm(both_2_4s, table_2_3, table_2_4a, table_2_4b)
```

We can now check that the sum of rural and urban is the same as the total.

```{r}
#| echo: true

follow_up <- 
  all |> 
  mutate(total_from_bits = total_rural + total_urban,
         check_total_is_rural_plus_urban = if_else(total == total_from_bits, 1, 0),
         total_from_bits - total) |> 
  filter(check_total_is_rural_plus_urban == 0)

head(follow_up)
rm(follow_up)
```

There are just a few, but as they only have a difference of 1, we will just move on.

Finally, we want to check that the single age counts sum to the age-groups.

```{r}
#| echo: true

follow_up <- 
  all |> 
  mutate(groups = case_when(age %in% c("0", "1", "2", "3", "4", "0-4") ~ "0-4",
                            age %in% c("5", "6", "7", "8", "9", "5-9") ~ "5-9",
                            age %in% c("10", "11", "12", "13", "14", "10-14") ~ "10-14",
                            age %in% c("15", "16", "17", "18", "19", "15-19") ~ "15-19",
                            age %in% c("20", "21", "22", "23", "24", "20-24") ~ "20-24",
                            age %in% c("25", "26", "27", "28", "29", "25-29") ~ "25-29",
                            age %in% c("30", "31", "32", "33", "34", "30-34") ~ "30-34",
                            age %in% c("35", "36", "37", "38", "39", "35-39") ~ "35-39",
                            age %in% c("40", "41", "42", "43", "44", "40-44") ~ "40-44",
                            age %in% c("45", "46", "47", "48", "49", "45-49") ~ "45-49",
                            age %in% c("50", "51", "52", "53", "54", "50-54") ~ "50-54",
                            age %in% c("55", "56", "57", "58", "59", "55-59") ~ "55-59",
                            age %in% c("60", "61", "62", "63", "64", "60-64") ~ "60-64",
                            age %in% c("65", "66", "67", "68", "69", "65-69") ~ "65-69",
                            age %in% c("70", "71", "72", "73", "74", "70-74") ~ "70-74",
                            age %in% c("75", "76", "77", "78", "79", "75-79") ~ "75-79",
                            age %in% c("80", "81", "82", "83", "84", "80-84") ~ "80-84",
                            age %in% c("85", "86", "87", "88", "89", "85-89") ~ "85-89",
                            age %in% c("90", "91", "92", "93", "94", "90-94") ~ "90-94",
                            age %in% c("95", "96", "97", "98", "99", "95-99") ~ "95-99",
                            TRUE ~ "Other")
         ) |> 
  group_by(area_type, area, groups) |> 
  mutate(group_sum = sum(total, na.rm = FALSE),
         group_sum = group_sum / 2,
         difference = total - group_sum) |> 
  ungroup() |> 
  filter(age == groups) |> 
  filter(total != group_sum) 

head(follow_up)

rm(follow_up)
```

Mt. Kenya Forest, Aberdare Forest, Kakamega Forest are all slightly dodgy. It does not seem to be in the documentation, but it looks like the Kenyan government has apportioned these between various countries. This is understandable, and unlikely to be a big deal, so, again, we will just move on.

### Tidy-up

Now that we are confident that everything is looking good, we can just convert it to tidy format. This will make it easier to work with.

```{r}
all <-
  all |>
  rename(male_total = male,
         female_total = female,
         total_total = total) |>
  pivot_longer(
    cols = c(
      male_total,
      female_total,
      total_total,
      male_rural,
      female_rural,
      total_rural,
      male_urban,
      female_urban,
      total_urban
    ),
    names_to = "type",
    values_to = "number"
  ) |>
  separate(
    col = type,
    into = c("gender", "part_of_area"),
    sep = "_"
  ) |>
  select(area, area_type, part_of_area, age, age_type, gender, number)

head(all)
```

```{r}
#| include: false
#| eval: false

write_csv(all, file = "outputs/data/cleaned_kenya_2019_census.csv")
```


The original purpose of cleaning this dataset was to make a table for @alexander2021bayesian. Just to bring this all together, we could make a graph of single-year counts, by gender, for Nairobi (@fig-monicasnairobigraph)).

```{r}
#| echo: true

monicas_dataset <- 
  all |> 
  filter(area_type == "county") |> 
  filter(part_of_area == "total") |>
  filter(age_type == "single-year") |> 
  select(area, age, gender, number)

head(monicas_dataset)
```

```{r}
#| label: fig-monicasnairobigraph
#| echo: true
#| fig-cap: "Distribution of age and gender in Nairobi in 2019, based on Kenyan census"

monicas_dataset |>
  filter(area == "Nairobi") |>
  filter(gender != "total") |>
  ggplot(aes(x = age, y = number, fill = gender)) +
  geom_col(aes(x = age, y = number, fill = gender), position = "dodge") +
  scale_y_continuous(labels = scales::comma) +
  scale_x_discrete(breaks = c(seq(from = 0, to = 99, by = 5), "100+")) +
  theme_classic()+
  scale_fill_brewer(palette = "Set1") +
  labs(y = "Number",
       x = "Age",
       fill = "Gender",
       caption = "Data source: 2019 Kenya Census")
```

A variety of features are clear from @fig-monicasnairobigraph, including age-heaping, a slight difference in the ratio of male-female birth, and a substantial difference between ages 15 and 25.



## Naming things

> An improved scanning software we developed identified gene name errors in 30.9% (3,436/11,117) of articles with supplementary Excel gene lists; a figure significantly higher than previously estimated. This is due to gene names being converted not just to dates and floating-point numbers, but also to internal date format (five-digit numbers).
>
> @omggenes

Names matter. The land on which much of this book was written is today named Canada, but for a long time was known as Turtle Island. Similarly, there is a big rock in the center of Australia. For a long time, it was called Uluru, then it was known as Ayers Rock. Today it has a dual name that combines both. And in parts of the US South, including signage surrounding the South Carolina State House, the US Civil War is referred to as the War of Northern Aggression. In these examples, the name that is used conveys information, not only about the user, but about the circumstances. Even the British Royal Family recognize the power of names. In 1917 they changed from the House of Saxe-Coburg and Gotha to the House of Windsor, due to a feeling that the former was too Germanic given World War I was ongoing. Names matter in everyday life. And they matter in data science too.

Names give places meaning, and by ignoring existing names, we ignore what has come before us. The importance of names, and of how existing relationships were ignored by re-naming, was clear in those earlier cases, but we see it in data science as well. We need to be careful when we name our datasets, our variables, and our functions. @tukey1962future essentially defined what we today call data science, but it was popularized by folks in computer science in the late 2000s who ignored, either deliberately or through ignorance, what came before them. With that came the renaming of concepts that were well-established in the fields that computer science had expanded into. For instance, the use of binary variables in regression, sometimes called 'dummy variables', is often called one-hot encoding in computer science. The social sciences went through a similar experience, starting in the 1980s, with economics expanding in a similarly (and self-described) imperialistic way [@lazear2000economic]. The social sciences now recognize the cost of this, and data science should try to avoid it. No area of study is ever actually without existing claims. And recognizing, adopting, and using existing names, and practices is important.

@kimmerer2013 [p. 34] describes how names are used to create homelands. She is talking with regard to physical places, but the same is true of our function names, our variable names and our dataset names. Names are critical and worthy of special attention because they help document our code as they are, by definition, contained in the code, they are a large part of any script, they are referred to a lot by others, and they help the reader understand what is happening in the code [@hermans2021programmer]. In addition to respecting the nature of the data, names need to satisfy two additional considerations: 

1) they need to be machine readable, and 
2) they need to be human readable.

Machine readable names is an easier standard to meet, but usually means avoiding spaces and special characters. A space can be replaced with an underscore. Usually, special characters should be removed because they can be inconsistent between different computers and languages. This is especially the case with slash and backslash, asterisk, and single and double quotation marks, none of which should, almost, ever be used in names. Names should also be unique within a dataset, and unique within a collection of datasets unless that particular column is being deliberately used as a key to join different datasets. This usually means that the domain is critical for effective names, and when working as part of a team this all gets much difficult [@hermans2017peter].

An especially useful function to use to get closer to machine readable names is `clean_names()` from `janitor` [@janitor]. This deals with those issues mentioned above as well as a few others.


```{r}
library(janitor)

bad_names_good_names <- 
  tibble(
    'First' = c(1),
    'second name has spaces' = c(1),
    'weird#symbol' = c(1),
    'InCoNsIsTaNtCaPs' = c(1)
  )

bad_names_good_names

bad_names_good_names <- 
  bad_names_good_names |> 
  clean_names()
  
bad_names_good_names
```

Human readable names require an additional layer. For instance, following @jsfcodingstandards [p. 25], we should avoid names that only differ by the use of the letter 'O', instead of the number '0' or the letter 'D'. Similarly, 'S' with '5'.  We need to consider other cultures and how they may interpret some of the names that we are using. We also need to consider different experience levels that subsequent users of the dataset may have. This is both in terms of experience with data science, but also experience with similar datasets. For instance, a column called 'flag' is often used to signal that a column contains data that needs to be followed up with or treated carefully in some way. An experienced analyst will know this, but a beginner will not. Try to use meaningful names wherever possible [@lin2020ten]. It has been found that shorter names may take longer to comprehend [@shorternamestakelonger], and so it is often useful to avoid uncommon abbreviations where possible.

@jennybryanonnames additionally recommends that file names, in particular, should consider the default ordering that a file manager will impose. This might mean adding prefixes such as '00-', '01-', etc to filenames, which might involve left-padding with zeros depending on the number of files. Critically it means using ISO 8601 for dates, which means that 2 December 2022 would be written '2022-12-02'. The reason for using such file names is to provide information to other people about the order of the files.

One interesting feature of R is that in certain cases partial matching on names is possible. For instance:

```{r}
never_use_partial_matching <- 
  data.frame(
    my_first_name = c(1, 2),
    another_name = c("wow", "great")
  )

never_use_partial_matching$my_first_name
never_use_partial_matching$my
```

This behavior is not possible within the `tidyverse`, for instance if `data.frame` were replaced with `tibble` in the above code. Partial matching should almost never be used. It makes it more difficult to understand code after a break, and for others to come to it fresh.

@columnnamesascontracts advises using column names as contracts, through establishing a controlled vocabulary for column names. In this way, we would define a set of words that we can use in column names. In the controlled vocabulary of @columnnamesascontracts a column could start with an abbreviation for its class, then something specific to what it pertains to, and then various details. For instance, in the Kenyan data example earlier we have the following column names:  "area", "age", "gender", and "number". If we were to use our column names as contracts, then these could be: "chr_area", "fctr_group_age", "chr_group_gender", and "int_group_count".

```{r}
column_names_as_contracts <- 
  monicas_dataset |> 
  rename(
    "chr_area" = "area",
    "fctr_group_age" = "age",
    "chr_group_gender" = "gender",
    "int_group_count" = "number"
  )
```

We can then use `pointblank` [@pointblank] to set-up tests for us.

```{r}
#| message: false
#| warning: false

library(pointblank)

agent <-
  create_agent(tbl = column_names_as_contracts) |>
  col_is_character(columns = vars(chr_area, chr_group_gender)) |>
  col_is_factor(columns = vars(fctr_group_age)) |>
  col_is_integer(columns = vars(int_group_count)) |>
  col_vals_in_set(columns = chr_group_gender,
                  set = c("male", "female", "total")) |>
  interrogate()

agent
```





## Exercises and tutorial

### Exercises {.unnumbered}

1. *(Plan)* Consider the following scenario: **TBD**. Please sketch what that dataset could look like and then sketch a graph that you could build to show all observations.
2. *(Simulate)* Please further consider the scenario described and simulate the situation with every variable independent of each other.
3. *(Acquire)* Please describe a possible source of such a dataset.
4. *(Explore)* Please use `ggplot2` to build the graph that you sketched.
5. *(Communicate)* Please write two paragraphs about what you did.
6. Is the following an example of tidy data? 

```{r}
tibble(name = c('Anne', 'Bethany', 'Stephen', 'William'),
       age_group = c('18-29', '30-44', '45-60', '60+'),
       )
```

7. If I am dealing with ages then what is the most likely class for the variable (select all that apply)?
    a. integer
    b. matrix
    c. numeric
    d. factor
8. With regard to 'AV Rule 48' from @jsfcodingstandards [p. 25] which of the following are not allowed to differ identifiers (select all that apply)?
    a.  Only a mixture of case
    b.  The presence/absence of the underscore character
    c.  The interchange of the letter 'O', with the number '0' or the letter 'D'
    d.  The interchange of the letter 'I', with the number '1' or the letter 'l'
    e.  The interchange of the letter 'S' with the number '5'
    f.  The interchange of the letter 'Z' with the number 2
    g.  The interchange of the letter 'n' with the letter 'h'

### Tutorial {.unnumbered}

This is a variant of a 'think-pair-share' exercise [@lyman1981responsive]. With regard to @Jordan2019Artificial, @datafeminism2020 [Chapter 6], @thatrandyauperson, and other relevant work, to what extent do you think we should let the data speak for themselves? Please write at least two pages. Following this, please pair with another student and exchange your written work. Update it if needed. Finally, please share your response with the rest of the class.

